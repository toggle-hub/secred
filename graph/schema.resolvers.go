package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/xsadia/secred/graph/model"
	itemmodel "github.com/xsadia/secred/pkg/models/items"
	orderitemmodel "github.com/xsadia/secred/pkg/models/order_items"
	ordermodel "github.com/xsadia/secred/pkg/models/orders"
	schoolorderitemmodel "github.com/xsadia/secred/pkg/models/school_order_items"
	schoolordermodel "github.com/xsadia/secred/pkg/models/school_orders"
	schoolmodel "github.com/xsadia/secred/pkg/models/schools"
	usermodel "github.com/xsadia/secred/pkg/models/user_model"
	"github.com/xsadia/secred/pkg/utils"
	authutils "github.com/xsadia/secred/pkg/utils/auth_utils"
	"github.com/xsadia/secred/pkg/utils/lists"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.CreateUserReturnType, error) {
	userModel := usermodel.New(r.DB)
	user, err := userModel.Create(input)
	if err != nil {
		log.Println("Failed to create user")
		return nil, gqlerror.Errorf(err.Error())
	}

	token, err := utils.CreateJWT(user.ID, utils.JWTExpireTime)
	if err != nil {
		log.Println("Failed to create JWT")
		return nil, gqlerror.Errorf(err.Error())
	}

	return &model.CreateUserReturnType{
		Me:    user,
		Token: &token,
	}, nil
}

// CreateSchool is the resolver for the createSchool field.
func (r *mutationResolver) CreateSchool(ctx context.Context, input model.CreateSchoolInput) (*model.School, error) {
	_, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	schoolModel := schoolmodel.New(r.DB)
	school, err := schoolModel.Create(input)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	return school, nil
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.CreateOrderInput) (*model.Order, error) {
	_, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	itemsInput := make([]model.CreateItemInput, len(input.Items))
	for i, entry := range input.Items {
		itemsInput[i] = model.CreateItemInput{
			Name:     entry.Name,
			Quantity: entry.Quantity,
		}
	}

	orderModel := ordermodel.New(r.DB)
	order, err := orderModel.Create(input.InvoiceURL)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	itemModel := itemmodel.New(r.DB)
	items, err := itemModel.LoadOrCreateManyByName(itemsInput)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	orderItemInput := make([]orderitemmodel.OrderItemCreateInput, len(items))
	mi := make(map[string]itemmodel.LoadCreateItem)
	for i, item := range items {
		for _, entry := range input.Items {
			if utils.RemoveDiacritics(strings.ToLower(entry.Name)) == item.Name {
				orderItemInput[i] = orderitemmodel.OrderItemCreateInput{
					OrderId:  order.ID,
					ItemId:   item.ID,
					Quantity: entry.Quantity,
				}
			}
		}

		mi[item.ID] = item
	}

	orderItemModel := orderitemmodel.New(r.DB)
	orderItems, err := orderItemModel.CreateMany(orderItemInput)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	updateItemInput := make([]itemmodel.UpdateItemInput, len(items))
	for i, orderItem := range orderItems {
		item := mi[orderItem.ItemId]
		var quantity int
		if item.Inserted {
			quantity = item.Quantity
		} else {
			quantity = item.Quantity + orderItem.Quantity
		}

		updateItemInput[i] = itemmodel.UpdateItemInput{
			ID:       item.ID,
			Name:     item.Name,
			Quantity: quantity,
		}
	}

	updatedItems, err := itemModel.UpdateMany(updateItemInput)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	for _, item := range updatedItems {
		mi[item.ID] = itemmodel.LoadCreateItem{
			Item: item,
		}
	}

	var modelOrderItems []*model.OrderItem
	for _, orderItem := range orderItems {
		item := mi[orderItem.ItemId]

		modelOrderItems = append(modelOrderItems, &model.OrderItem{
			ID:        orderItem.ID,
			Quantity:  orderItem.Quantity,
			Item:      item.Item,
			CreatedAt: orderItem.CreatedAt,
			UpdatedAt: orderItem.UpdatedAt,
			DeletedAt: orderItem.DeletedAt,
		})
	}

	return &model.Order{
		ID:         order.ID,
		OrderItems: modelOrderItems,
		InvoiceURL: order.InvoiceUrl,
		CreatedAt:  order.CreatedAt,
		UpdatedAt:  order.UpdatedAt,
		DeletedAt:  order.DeletedAt,
	}, nil
}

// CreateSchoolOrder is the resolver for the createSchoolOrder field.
func (r *mutationResolver) CreateSchoolOrder(ctx context.Context, input model.CreateSchoolOrderInput) (*model.SchoolOrder, error) {
	_, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	schoolModel := schoolmodel.New(r.DB)
	school, err := schoolModel.FindById(input.School)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	itemModel := itemmodel.New(r.DB)
	items, err := itemModel.LoadManyByName(
		lists.Map(
			input.Items, func(elem *model.CreateOrderItemInput, _ int, _ []*model.CreateOrderItemInput) string {
				return elem.Name
			}),
	)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	foundItemsMap := lists.Reduce(
		items,
		map[string]*model.Item{},
		func(acc map[string]*model.Item, elem *model.Item) map[string]*model.Item {
			acc[elem.Name] = elem

			return acc
		})

	if len(input.Items) != len(items) {
		var notFoundItems []string
		for _, entry := range input.Items {
			if _, ok := foundItemsMap[utils.RemoveDiacritics(strings.ToLower(entry.Name))]; !ok {
				notFoundItems = append(notFoundItems, entry.Name)
			}
		}

		errMessage := lists.Reduce(
			notFoundItems,
			"could not find items with names: [",
			func(acc string, elem string) string {
				return acc + fmt.Sprintf("%s, ", elem)
			})

		errMessage = errMessage[:len(errMessage)-2] + "]"
		return nil, gqlerror.Errorf(errMessage)
	}

	schoolOrderModel := schoolordermodel.New(r.DB)
	order, err := schoolOrderModel.Create(school.ID)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	var createManyInput []schoolorderitemmodel.SchoolOrderItemCreateInput
	var updateItemsInput []itemmodel.UpdateItemInput
	for _, entry := range input.Items {
		item := foundItemsMap[utils.RemoveDiacritics(strings.ToLower(entry.Name))]
		if entry.Quantity > item.Quantity {
			return nil, gqlerror.Errorf("insufficient quantity for item %s", entry.Name)
		}

		createManyInput = append(createManyInput, schoolorderitemmodel.SchoolOrderItemCreateInput{
			ItemID:   item.ID,
			OrderID:  order.ID,
			Quantity: entry.Quantity,
		})

		updateItemsInput = append(updateItemsInput, itemmodel.UpdateItemInput{
			ID:       item.ID,
			Name:     item.Name,
			Quantity: item.Quantity - entry.Quantity,
		})
	}

	schoolOrderItemModel := schoolorderitemmodel.New(r.DB)
	schoolOrderItems, err := schoolOrderItemModel.CreateMany(createManyInput)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	_, err = itemModel.UpdateMany(updateItemsInput)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	orderItemMap := lists.Reduce(
		schoolOrderItems,
		map[string]*schoolorderitemmodel.SchoolOrderItem{},
		func(acc map[string]*schoolorderitemmodel.SchoolOrderItem, elem *schoolorderitemmodel.SchoolOrderItem) map[string]*schoolorderitemmodel.SchoolOrderItem {
			acc[elem.ItemID] = elem
			return acc
		})

	var orderItems []*model.SchoolOrderItem
	for _, item := range items {
		orderItem := orderItemMap[item.ID]

		orderItems = append(orderItems, &model.SchoolOrderItem{
			ID:        orderItem.ID,
			Name:      item.Name,
			Quantity:  orderItem.Quantity,
			CreatedAt: orderItem.CreatedAt,
			UpdatedAt: orderItem.UpdatedAt,
			DeletedAt: orderItem.DeletedAt,
		})
	}

	return &model.SchoolOrder{
		ID:         order.ID,
		SchoolID:   school.ID,
		OrderItems: orderItems,
		CreatedAt:  order.CreatedAt,
		UpdatedAt:  order.UpdatedAt,
		DeletedAt:  order.DeletedAt,
	}, nil
}

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input model.CreateItemInput) (*model.Item, error) {
	_, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	itemModel := itemmodel.New(r.DB)
	item, err := itemModel.Create(input)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	return item, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	return user, nil
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context, page *int, limit *int) (*model.Items, error) {
	_, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	itemModel := itemmodel.New(r.DB)
	items, hasNextPage := itemModel.LoadMany(*page, *limit)

	return &model.Items{
		Nodes: items,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNextPage,
		},
	}, nil
}

// Schools is the resolver for the schools field.
func (r *queryResolver) Schools(ctx context.Context, page *int, limit *int) (*model.Schools, error) {
	_, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	schoolModel := schoolmodel.New(r.DB)
	schools, hasNextPage := schoolModel.LoadMany(*page, *limit)

	return &model.Schools{
		Nodes: schools,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNextPage,
		},
	}, nil
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	panic(fmt.Errorf("not implemented: Orders - orders"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
