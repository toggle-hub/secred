package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/xsadia/secred/graph/model"
	itemmodel "github.com/xsadia/secred/pkg/models/item_model"
	schoolmodel "github.com/xsadia/secred/pkg/models/school_model"
	usermodel "github.com/xsadia/secred/pkg/models/user_model"
	"github.com/xsadia/secred/pkg/utils"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.CreateUserReturnType, error) {
	userModel := usermodel.New(r.DB)
	user, err := userModel.Create(input)
	if err != nil {
		log.Println("Failed to create user")
		return nil, gqlerror.Errorf(err.Error())
	}

	token, err := utils.CreateJWT(user.ID, utils.JWTExpireTime)
	if err != nil {
		log.Println("Failed to create JWT")
		return nil, gqlerror.Errorf(err.Error())
	}

	return &model.CreateUserReturnType{
		Me:    user,
		Token: &token,
	}, nil
}

// CreateSchool is the resolver for the createSchool field.
func (r *mutationResolver) CreateSchool(ctx context.Context, input model.CreateSchoolInput) (*model.School, error) {
	id, err := utils.GetUserFromContext(ctx)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	userModel := usermodel.New(r.DB)
	_, err = userModel.FindById(id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, gqlerror.Errorf("authorization required")
		}

		return nil, gqlerror.Errorf("unexpected error")
	}

	schoolModel := schoolmodel.New(r.DB)
	school, err := schoolModel.Create(input)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	return school, nil
}

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input model.CreateItemInput) (*model.Item, error) {
	id, err := utils.GetUserFromContext(ctx)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	userModel := usermodel.New(r.DB)
	_, err = userModel.FindById(id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, gqlerror.Errorf("authorization required")
		}

		return nil, gqlerror.Errorf("unexpected error")
	}

	itemModel := itemmodel.New(r.DB)
	item, err := itemModel.Create(input)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	return item, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	id, err := utils.GetUserFromContext(ctx)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	userModel := usermodel.New(r.DB)

	user, err := userModel.FindById(id)
	if err == nil {
		return user, nil
	}

	if errors.Is(err, sql.ErrNoRows) {
		log.Println(err)
		return nil, gqlerror.Errorf("Authorization required")
	}

	return nil, gqlerror.Errorf("Unexpected error")
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context, page *int, limit *int) (*model.Items, error) {
	id, err := utils.GetUserFromContext(ctx)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	userModel := usermodel.New(r.DB)
	_, err = userModel.FindById(id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, gqlerror.Errorf("authorization required")
		}

		return nil, gqlerror.Errorf("unexpected error")
	}

	itemModel := itemmodel.New(r.DB)
	items, hasNextPage := itemModel.LoadAll(*page, *limit)

	return &model.Items{
		Nodes: items,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNextPage,
		},
	}, nil
}

// Schools is the resolver for the schools field.
func (r *queryResolver) Schools(ctx context.Context) ([]*model.School, error) {
	panic(fmt.Errorf("not implemented: Schools - schools"))
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	panic(fmt.Errorf("not implemented: Orders - orders"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
