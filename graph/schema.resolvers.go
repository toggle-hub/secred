package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/xsadia/secred/graph/model"
	itemmodel "github.com/xsadia/secred/pkg/models/item_model"
	orderitemmodel "github.com/xsadia/secred/pkg/models/order_item_model"
	ordermodel "github.com/xsadia/secred/pkg/models/order_model"
	schoolmodel "github.com/xsadia/secred/pkg/models/school_model"
	usermodel "github.com/xsadia/secred/pkg/models/user_model"
	"github.com/xsadia/secred/pkg/utils"
	authutils "github.com/xsadia/secred/pkg/utils/auth_utils"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.CreateUserReturnType, error) {
	userModel := usermodel.New(r.DB)
	user, err := userModel.Create(input)
	if err != nil {
		log.Println("Failed to create user")
		return nil, gqlerror.Errorf(err.Error())
	}

	token, err := utils.CreateJWT(user.ID, utils.JWTExpireTime)
	if err != nil {
		log.Println("Failed to create JWT")
		return nil, gqlerror.Errorf(err.Error())
	}

	return &model.CreateUserReturnType{
		Me:    user,
		Token: &token,
	}, nil
}

// CreateSchool is the resolver for the createSchool field.
func (r *mutationResolver) CreateSchool(ctx context.Context, input model.CreateSchoolInput) (*model.School, error) {
	_, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	schoolModel := schoolmodel.New(r.DB)
	school, err := schoolModel.Create(input)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	return school, nil
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input *model.CreateOrderInput) (*model.Order, error) {
	_, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	itemsInput := make([]model.CreateItemInput, len(input.Items))
	for i, entry := range input.Items {
		itemsInput[i] = model.CreateItemInput{
			Name:     entry.Name,
			Quantity: entry.Quantity,
		}
	}

	orderModel := ordermodel.New(r.DB)
	order, err := orderModel.Create(input.InvoiceURL)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	itemModel := itemmodel.New(r.DB)
	items, err := itemModel.LoadOrCreateManyByName(itemsInput)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	orderItemInput := make([]orderitemmodel.OrderItemCreateInput, len(items))
	mi := make(map[string]itemmodel.LoadCreateItem)
	for i, item := range items {
		for _, entry := range input.Items {
			if utils.RemoveDiacritics(strings.ToLower(entry.Name)) == item.Name {
				orderItemInput[i] = orderitemmodel.OrderItemCreateInput{
					OrderId:  order.ID,
					ItemId:   item.ID,
					Quantity: entry.Quantity,
				}
			}
		}

		mi[item.ID] = item
	}

	orderItemModel := orderitemmodel.New(r.DB)
	orderItems, err := orderItemModel.CreateMany(orderItemInput)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	updateItemInput := make([]itemmodel.UpdateItemInput, len(items))
	for i, orderItem := range orderItems {
		item := mi[orderItem.ItemId]
		var quantity int
		if item.Inserted {
			quantity = item.Quantity
		} else {
			quantity = item.Quantity + orderItem.Quantity
		}

		updateItemInput[i] = itemmodel.UpdateItemInput{
			ID:       item.ID,
			Name:     item.Name,
			Quantity: quantity,
		}
	}

	updatedItems, err := itemModel.UpdateMany(updateItemInput)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	for _, item := range updatedItems {
		mi[item.ID] = itemmodel.LoadCreateItem{
			Item: item,
		}
	}

	var modelOrderItems []*model.OrderItem
	for _, orderItem := range orderItems {
		item := mi[orderItem.ItemId]

		modelOrderItems = append(modelOrderItems, &model.OrderItem{
			ID:        orderItem.ID,
			Quantity:  orderItem.Quantity,
			Item:      item.Item,
			CreatedAt: orderItem.CreatedAt,
			UpdatedAt: orderItem.UpdatedAt,
			DeletedAt: orderItem.DeletedAt,
		})
	}

	return &model.Order{
		ID:         order.ID,
		OrderItems: modelOrderItems,
		InvoiceURL: order.InvoiceUrl,
		CreatedAt:  order.CreatedAt,
		UpdatedAt:  order.UpdatedAt,
		DeletedAt:  order.DeletedAt,
	}, nil
}

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input model.CreateItemInput) (*model.Item, error) {
	_, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	itemModel := itemmodel.New(r.DB)
	item, err := itemModel.Create(input)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	return item, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	return user, nil
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context, page *int, limit *int) (*model.Items, error) {
	_, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	itemModel := itemmodel.New(r.DB)
	items, hasNextPage := itemModel.LoadMany(*page, *limit)

	return &model.Items{
		Nodes: items,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNextPage,
		},
	}, nil
}

// Schools is the resolver for the schools field.
func (r *queryResolver) Schools(ctx context.Context, page *int, limit *int) (*model.Schools, error) {
	_, err := authutils.AuthenticateUser(ctx, r.DB)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	schoolModel := schoolmodel.New(r.DB)
	schools, hasNextPage := schoolModel.LoadMany(*page, *limit)

	return &model.Schools{
		Nodes: schools,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNextPage,
		},
	}, nil
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	panic(fmt.Errorf("not implemented: Orders - orders"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
